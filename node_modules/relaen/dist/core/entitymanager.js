"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityManager = void 0;
const types_1 = require("./types");
const sqlexecutor_1 = require("./sqlexecutor");
const entityfactory_1 = require("./entityfactory");
const query_1 = require("./query");
const error_1 = require("./message/error");
const nativequery_1 = require("./nativequery");
const entitymanagerfactory_1 = require("./entitymanagerfactory");
const baseentity_1 = require("./baseentity");
const translatorfactory_1 = require("./translatorfactory");
const connectionmanager_1 = require("./connectionmanager");
const relaenmanager_1 = require("./relaenmanager");
/**
 * 实体管理器
 */
class EntityManager {
    /**
     * 构造函数
     * @param conn -  连接对象
     * @param id -    entity manager id
     */
    constructor(conn, id, isCache) {
        /**
         * 查询结果集缓存
         *     key:sql语句和参数值组合成的字符串，value:查询结果集
         */
        this.cache = new Map();
        this.id = id;
        this.connection = conn;
        this.isCache = isCache;
        this.cache = new Map();
    }
    /**
     * 保存新对象
     * 如果状态为new，则执行insert，同时改变为persist，如果为persist，则执行update
     * @param entity -                实体
     * @param ignoreUndefinedValue -  忽略undefined值，针对update时有效
     * @param lockMode -              乐观锁，针对update时有效
     * @returns                     保存后的实体
     */
    async save(entity, ignoreUndefinedValue) {
        //先进行预处理
        if (!this.preHandleEntity(entity, ignoreUndefinedValue)) {
            return null;
        }
        const status = entitymanagerfactory_1.EntityManagerFactory.getEntityStatus(entity);
        const translator = translatorfactory_1.TranslatorFactory.get(entity.constructor.name);
        //无主键或状态为new
        if (status === types_1.EEntityState.NEW) {
            //检查并生成主键
            const idValue = entityfactory_1.EntityFactory.getIdValue(entity);
            let sqlAndValue;
            if (idValue) { //存在主键
                //如果有主键，则查询是否存在对应实体
                const en = await this.find(entity.constructor.name, idValue);
                if (en) { //如果该实体已存在，则执行update
                    sqlAndValue = translator.entityToUpdate(entity, ignoreUndefinedValue);
                }
                else { //实体不存在，则执行insert
                    sqlAndValue = translator.entityToInsert(entity);
                }
            }
            else { //无主键
                //根据策略生成主键
                await this.genKey(entity);
                sqlAndValue = translator.entityToInsert(entity);
            }
            const r = await sqlexecutor_1.SqlExecutor.exec(this, sqlAndValue[0], sqlAndValue[1]);
            if (r === null) {
                return;
            }
            //修改状态
            entitymanagerfactory_1.EntityManagerFactory.setEntityStatus(entity, types_1.EEntityState.PERSIST);
            //设置主键值
            if (!entityfactory_1.EntityFactory.getIdValue(entity)) {
                entityfactory_1.EntityFactory.setIdValue(entity, connectionmanager_1.ConnectionManager.provider.getIdentityId(r));
            }
        }
        else { //update
            //更新到数据库
            const sqlAndValue = translator.entityToUpdate(entity, ignoreUndefinedValue);
            const r = await sqlexecutor_1.SqlExecutor.exec(this, sqlAndValue[0], sqlAndValue[1]);
            if (r === null) {
                return null;
            }
        }
        return entity;
    }
    /**
     * 删除实体
     * @param entity -      待删除实体或id
     * @param className -   实体类名
     * @returns             被删除实体
     */
    async delete(entity, className) {
        if (entity instanceof baseentity_1.BaseEntity) {
            className = entity.constructor.name;
        }
        const translator = translatorfactory_1.TranslatorFactory.get(className);
        const sqlAndValue = translator.toDelete(entity);
        if (sqlAndValue) {
            await sqlexecutor_1.SqlExecutor.exec(this, sqlAndValue[0], [sqlAndValue[1]]);
        }
        return true;
    }
    /**
     * 通过id查找实体
     * @param entityClassName -     entity class 名
     * @param id -                  entity id 值
     * @returns                     entity
     */
    async find(entityClassName, id) {
        const eo = entityfactory_1.EntityFactory.getEntityConfig(entityClassName);
        if (!eo) {
            throw new error_1.RelaenError("0010", entityClassName);
        }
        const sql = "SELECT " + this.getSelectFields(eo, true) + " FROM " + eo.getTableName(true) + " WHERE " + eo.getIdName() + '=?';
        const query = this.createNativeQuery(sql, entityClassName);
        query.setParameter(0, id);
        return await query.getResult();
    }
    /**
     * 根据条件查找一个对象
     * @param entityClassName - 实体类名
     * @param params - 参数对象
     * 参数值有两种方式，一种是值，一种是值对象，值对象参考CondValueOption接口说明，示例如下：
     * ```json
     * {
     *      propName1:propValue1, //值
     *      propName2:{value:propValue2,rel:'>',before:'(',after:')',logic:'OR'} //值对象
     *      ...
     *  }
     * ```
     * @param order -  排序对象，结构为：
     * ```json
     *  {
     *      propName1:asc,
     *      propName2:desc,
     *      ...
     *  }
     * ```
     * @returns   实体
     */
    async findOne(entityClassName, params, order) {
        const lst = await this.findMany(entityClassName, params, 0, 1, order);
        if (lst && lst.length > 0) {
            return lst[0];
        }
    }
    /**
     * 根据条件查找多个对象
     * @param entityClassName - 实体类名
     * @param params -          参数对象，参考findOne
     * @param start -           开始记录行
     * @param limit -           获取记录数
     * @param order -           排序对象，参考findOne
     * @returns                 实体集
     */
    async findMany(entityClassName, params, start, limit, order) {
        const orm = entityfactory_1.EntityFactory.getEntityConfig(entityClassName);
        if (!orm) {
            throw new error_1.RelaenError("0010", entityClassName);
        }
        const query = this.createQuery(entityClassName);
        return await query.select(this.getSelectFields(orm))
            .where(params)
            .orderBy(order)
            .getResultList(start, limit);
    }
    /**
     * 获取选择字段集
     * @param orm -       实体配置
     * @param isField -   默认返回属性名，true返回数据库字段字符串
     * @returns         字段集
     */
    getSelectFields(orm, isField) {
        const arr = [];
        for (const [key, value] of orm.columns) {
            //不要隐藏字段、外键
            if (value.select !== false && !orm.hasRelation(key)) {
                arr.push(isField ? value.name : key);
            }
        }
        ;
        if (isField) {
            if (arr.length === 0) {
                return '*';
            }
            return arr.join(',');
        }
        return arr;
    }
    /**
     * 获取记录数
     * @param entityClassName -   实体类名
     * @param params -            参数对象，参考findOne
     * @returns                 记录数
     */
    async getCount(entityClassName, params) {
        const query = this.createQuery(entityClassName);
        return await query.select('count(*)')
            .where(params)
            .getResult(true);
    }
    /**
     * 删除多个
     * @param entityClassName -   实体类名
     * @param params -            条件参数，参考findOne
     * @returns                 成功:true，失败:false
     */
    async deleteMany(entityClassName, params) {
        return await this.createQuery(entityClassName).delete().where(params).getResult();
    }
    /**
     * 创建查询对象
     * @param entityClassName -   实体类名
     * @returns                 查询对象
     */
    createQuery(entityClassName) {
        return new query_1.Query(this, entityClassName);
    }
    /**
     * 创建原生sql查询
     * @param sql -               sql语句
     * @param entityClassName -   实体类名
     * @returns                 原生查询对象
     */
    createNativeQuery(sql, entityClassName) {
        return new nativequery_1.NativeQuery(sql, this, entityClassName);
    }
    /**
     * 关闭entity manager
     * @param force -     是否强制关闭
     */
    async close(force) {
        entitymanagerfactory_1.EntityManagerFactory.closeEntityManager(this, force);
    }
    /**
     * 加入cache
     * @param key -       key
     * @param value -     结果集
     */
    addToCache(key, value) {
        if (this.cache) {
            this.cache.set(key, value);
        }
    }
    /**
     * 从cache中获取
     * @param key -   缓存key
     */
    getFromCache(key) {
        return this.cache.get(key);
    }
    /**
     * 清除缓存
     */
    clearCache() {
        this.cache.clear();
    }
    /**
     * 生成主键
     * @param entity -    实体
     * @returns          主键值
     */
    async genKey(entity) {
        //如果generator为table，则从指定主键生成表中获取主键，并赋予entity
        const eo = entityfactory_1.EntityFactory.getEntityConfig(entity.constructor.name);
        const idCfg = eo.getId();
        let value;
        switch (idCfg.generator) {
            case 'sequence':
                value = await connectionmanager_1.ConnectionManager.provider.getSequenceValue(this, idCfg.seqName, eo.schema);
                //抛出异常
                if (!value) {
                    throw new error_1.RelaenError("0051", (eo.schema || '') + idCfg.seqName);
                }
                break;
            case 'table':
                const fn = idCfg.keyName;
                const tx = this.connection.createTransaction();
                // sqlite 使用begin immediate替代begin开启事务，其它数据库开启事务
                if (relaenmanager_1.RelaenManager.dialect === 'sqlite') {
                    tx.setType(types_1.ESqliteTransactionType.IMMEDIATE);
                }
                await tx.begin();
                // 加表锁，需要单独执行语句
                const locksql = connectionmanager_1.ConnectionManager.provider.lock(types_1.ELockType.TABLEWRITE, [eo.table], eo.schema);
                if (locksql) {
                    await this.createNativeQuery(locksql).getResult();
                }
                // 查询主键值
                let query = this.createNativeQuery("SELECT " + idCfg.valueName + " FROM " +
                    eo.getTableName(true) + " WHERE " + idCfg.columnName + " ='" + fn + "'");
                const r = await query.getResult();
                if (r) {
                    //转换为整数
                    value = parseInt(r);
                    query = this.createNativeQuery("UPDATE " + eo.getTableName(true) +
                        " SET " + idCfg.valueName + "=" + (++value) +
                        " WHERE " + idCfg.columnName + " ='" + fn + "'");
                    await query.getResult();
                }
                //处理不是commit/rollback的释放锁
                const endLock = connectionmanager_1.ConnectionManager.provider.unlock(types_1.ELockType.TABLEWRITE);
                if (endLock) {
                    await this.createNativeQuery(endLock).getResult();
                }
                //释放锁
                await tx.commit();
                // 没有查询到主键抛错
                if (!value) {
                    throw new error_1.RelaenError('0401', entity.constructor.name);
                }
                break;
            case 'uuid':
                value = require('uuid').v1();
                break;
        }
        //设置主键值
        if (value) {
            entityfactory_1.EntityFactory.setIdValue(entity, value);
        }
    }
    /**
     * 预处理实体对象
     * @param entity -                实体对象
     * @param ignoreUndefinedValue -  忽略undefined值
     * @throws                      处理错误
     * @returns                     成功true
     */
    preHandleEntity(entity, ignoreUndefinedValue) {
        const className = entity.constructor.name;
        const eo = entityfactory_1.EntityFactory.getEntityConfig(className);
        if (!eo) {
            throw new error_1.RelaenError("0010", className);
        }
        for (const key of eo.columns) {
            const fo = key[1];
            let v;
            if (fo.refName) { //外键，只取主键
                if (typeof entity[key[0]] === 'object') {
                    const eo1 = entityfactory_1.EntityFactory.getEntityConfig(eo.getRelation(key[0]).entity);
                    v = entity[key[0]][eo1.getId().name];
                }
            }
            else {
                v = entity[key[0]]; //赋值，用于长度和为空检查
            }
            if ((v === null || v === undefined)) {
                if (!ignoreUndefinedValue && !fo.nullable) { //null 判断
                    if (key[0] !== eo.id.name) { //如果与主键不同且不能为空，则抛出异常 
                        throw new error_1.RelaenError('0021', key[0]);
                    }
                }
                entity[key[0]] = null;
            }
            else if (key[1].length && v.length > key[1].length) { //长度检测
                throw new error_1.RelaenError('0024', className, key[0], key[1].length);
            }
        }
        return true;
    }
}
exports.EntityManager = EntityManager;
//# sourceMappingURL=entitymanager.js.map