"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEntityManager = exports.EntityManagerFactory = void 0;
const entitymanager_1 = require("./entitymanager");
const connectionmanager_1 = require("./connectionmanager");
const relaenutil_1 = require("./relaenutil");
const threadlocal_1 = require("./threadlocal");
const relaenmanager_1 = require("./relaenmanager");
/**
 * entity manager 工厂
 */
class EntityManagerFactory {
    /**
     * 创建 entity manager，使用后需要释放
     * @param isCache -   是否开启缓存
     * @returns         实体管理器
     */
    static async createEntityManager(isCache) {
        const id = relaenutil_1.RelaenUtil.genId();
        const conn = await (0, connectionmanager_1.getConnection)(id);
        const sid = conn.threadId;
        let em;
        if (!this.entityManagerMap.has(sid)) {
            em = new entitymanager_1.EntityManager(conn, id, isCache);
            this.entityManagerMap.set(sid, {
                num: 1,
                em: em
            });
        }
        else {
            const o = this.entityManagerMap.get(sid);
            o.num++;
            em = o.em;
        }
        return em;
    }
    /**
     * 关闭entitymanager
     * @param em -        实体管理器
     * @param force -     是否强制关闭
     */
    static async closeEntityManager(em, force) {
        //获取threadId
        const sid = em.connection.threadId;
        if (!sid || !this.entityManagerMap.has(sid)) {
            return;
        }
        if (!force) {
            const o = this.entityManagerMap.get(sid);
            if (--o.num <= 0) {
                force = true;
            }
        }
        if (force) {
            //清除缓存
            em.clearCache();
            //从map移除
            this.entityManagerMap.delete(sid);
            //如果connection的创建者id与该entitymanager一致，则也需要释放该connection
            if (em.id && em.id === em.connection.fromId) {
                await em.connection.close(true);
            }
            else {
                await em.connection.close();
            }
        }
    }
    /**
     * 根据id获取entity manager
     * @param id    entity manager id
     * @returns     entity manager
     */
    static getEntityManager(id) {
        const obj = this.entityManagerMap.get(id);
        if (obj) {
            return obj.em;
        }
    }
    /**
     * 获取当前entitymanager，使用后不用释放
     * @returns     实体管理器
     */
    static getCurrentEntityManager() {
        const sid = threadlocal_1.RelaenThreadLocal.getThreadId();
        if (!sid || !this.entityManagerMap.has(sid)) {
            return null;
        }
        return this.entityManagerMap.get(sid).em;
    }
    /**
     * 关闭当前entity manager
     */
    static closeCurrentEntityManager() {
        const em = this.getCurrentEntityManager();
        if (em) {
            this.closeEntityManager(em);
        }
    }
    /**
     * 设置实体状态
     * @param entity -    实体
     * @param state -     状态
     */
    static setEntityStatus(entity, state) {
        this.entityStatusMap.set(entity, state);
    }
    /**
     * 获取实体状态
     * @param entity -    实体对象
     * @returns         实体状态或undefined
     */
    static getEntityStatus(entity) {
        return this.entityStatusMap.get(entity);
    }
}
exports.EntityManagerFactory = EntityManagerFactory;
/**
 * 连接map
 * @remarks
 * 用于保证一个异步方法中只能有一个entitymanager，结构为：
 * ```json
 * {
 *  threadId:{
 *      num:em创建次数,
 *      em:entity manager
 *  }
 * }
 * ```
 */
EntityManagerFactory.entityManagerMap = new Map();
/**
 * 实体状态map
 */
EntityManagerFactory.entityStatusMap = new WeakMap();
/**
 * 返回entity manager
 * @param isCache -   是否开启缓存
 * @returns         实体管理器
 */
async function getEntityManager(isCache) {
    isCache = typeof isCache === "boolean" ? isCache : relaenmanager_1.RelaenManager.cache;
    return await EntityManagerFactory.createEntityManager(isCache);
}
exports.getEntityManager = getEntityManager;
//# sourceMappingURL=entitymanagerfactory.js.map