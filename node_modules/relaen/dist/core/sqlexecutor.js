"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqlExecutor = void 0;
const logger_1 = require("./logger");
const relaenutil_1 = require("./relaenutil");
const connectionmanager_1 = require("./connectionmanager");
const error_1 = require("./message/error");
const tipmanager_1 = require("./message/tipmanager");
/**
 * sql执行器
 */
class SqlExecutor {
    /**
     * 执行mysql sql语句
     * @param em -          EntityManager
     * @param sql -         待执行sql
     * @param params -      参数数组
     * @param start -       开始记录行
     * @param limit -       最大记录行
     * @returns             执行结果
     */
    static async exec(em, sql, params, start, limit) {
        if (!sql) {
            return null;
        }
        sql = sql.trim();
        //sql类型：0:查询 1:增删改
        const type = sql.substring(0, 6).toLowerCase();
        if (!['select', 'insert', 'update', 'delete'].includes(type)) {
            throw new error_1.RelaenError('0002', sql);
        }
        //缓存key，构建方式：sql_paramsvaluestring
        let key;
        //结果
        let result;
        if (type === 'select') { //查询可从缓存中获取
            //sql语句末加行锁，分页加在行锁语句前（待优化加锁分页执行顺序）
            if (sql.substring(sql.length - 10).toLowerCase() === 'for update') {
                sql = connectionmanager_1.ConnectionManager.provider.handleStartAndLimit(sql.substring(0, sql.length - 11), start, limit) + ' FOR UPDATE';
            }
            else {
                sql = connectionmanager_1.ConnectionManager.provider.handleStartAndLimit(sql, start, limit);
            }
            key = sql;
            //构造缓存key
            if (params) {
                key += '_' + JSON.stringify(params);
            }
            //从缓存获取
            result = em.getFromCache(key);
            //缓存中存在，则直接返回
            if (result) {
                return result;
            }
        }
        //处理占位符
        sql = relaenutil_1.RelaenUtil.handlePlaceholder(sql);
        //打印sql
        logger_1.Logger.log(sql, params);
        try {
            result = await connectionmanager_1.ConnectionManager.provider.exec(em.connection, sql, params);
            //执行增删改，则清空cache
            if (type !== 'select') {
                em.clearCache();
            }
            else { //添加到缓存
                em.addToCache(key, result);
            }
        }
        catch (e) {
            logger_1.Logger.error(e);
            throw new error_1.RelaenError(e.message);
        }
        logger_1.Logger.log(tipmanager_1.RelaenTipManager.getTip('ok'));
        return result;
    }
}
exports.SqlExecutor = SqlExecutor;
//# sourceMappingURL=sqlexecutor.js.map