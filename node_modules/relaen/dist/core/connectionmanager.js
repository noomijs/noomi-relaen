"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConnection = exports.ConnectionManager = void 0;
const relaenmanager_1 = require("./relaenmanager");
const connection_1 = require("./connection");
const threadlocal_1 = require("./threadlocal");
const providerfactory_1 = require("./providerfactory");
const error_1 = require("./message/error");
const entitymanagerfactory_1 = require("./entitymanagerfactory");
/**
 * 连接管理器
 */
class ConnectionManager {
    /**
     * 初始化连接管理器
     * @param cfg - relaen配置文件的数据库配置对象
     */
    static init(cfg) {
        const providerClass = providerfactory_1.ProviderFactory.get();
        if (!providerClass) {
            throw new error_1.RelaenError("0300", relaenmanager_1.RelaenManager.dialect);
        }
        this.provider = Reflect.construct(providerClass, [cfg]);
    }
    /**
     * 获取连接对象
     * @param id -   创建者id，直接使用时，不需要设置该值
     * @returns    connection对象
     */
    static async createConnection(id) {
        let conn;
        //把conn加入connectionMap
        let sid = threadlocal_1.RelaenThreadLocal.getThreadId();
        if (!sid) { //新建conn
            sid = threadlocal_1.RelaenThreadLocal.newThreadId();
        }
        if (!this.connectionMap.has(sid)) { //线程id对应对象不存在
            conn = new connection_1.Connection(await this.provider.getConnection());
            if (id) {
                conn.fromId = id;
            }
            conn.connected = true;
            conn.threadId = sid;
            //加入connection map 
            this.connectionMap.set(sid, conn);
        }
        else { //已存在，则只修改conn的创建数，不新建conn
            conn = this.connectionMap.get(sid);
            conn.useCount++;
        }
        return conn;
    }
    /**
     * 关闭连接
     * @param connection -    数据库连接对象
     * @param force -         是否强制释放
     */
    static async closeConnection(connection, force) {
        //获取threadId
        const sid = connection.threadId;
        //非强制释放，检查计数器
        if (!force) {
            if (sid && this.connectionMap.has(sid)) {
                const conn = this.connectionMap.get(sid);
                if (--conn.useCount <= 0) { //最后一个close，需要从map删除
                    force = true;
                }
            }
        }
        //需要释放
        if (force) {
            //清理 connection map
            this.connectionMap.delete(sid);
            //关闭关联entitymanager
            if (connection.fromId) {
                const em = entitymanagerfactory_1.EntityManagerFactory.getEntityManager(connection.fromId);
                if (em) {
                    entitymanagerfactory_1.EntityManagerFactory.closeEntityManager(em, true);
                }
            }
            return await this.provider.closeConnection(connection);
        }
    }
    /**
     * 添加conn到map
     * @param threadId -      线程id
     * @param conn -          连接对象
     */
    static addConnection(threadId, conn) {
        this.connectionMap.set(threadId, conn);
    }
    /**
     * 从map移除connection
     * @param threadId -      线程id
     */
    static removeConnection(threadId) {
        this.connectionMap.delete(threadId);
    }
}
exports.ConnectionManager = ConnectionManager;
/**
 * 连接map
 * @remarks
 * 用于保证一个异步方法中只能有一个connection
 * ```
 * {
 *      threadId1:connection1
 *  }
 * }
 * ```
 */
ConnectionManager.connectionMap = new Map();
/**
 * 获取连接对象
 * @param id -   创建者id，直接使用时，不需要设置该值
 * @returns    connection对象
 */
async function getConnection(id) {
    return await ConnectionManager.createConnection(id);
}
exports.getConnection = getConnection;
//# sourceMappingURL=connectionmanager.js.map